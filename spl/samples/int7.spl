breakpoint;
alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP/512)] * 512) + (SP % 512);
alias syscall S1;
syscall = [physicalSP - 1];
alias pid  S2;
alias cpcb S3;
alias count S4;
alias indexswoft S5;
if(syscall == 10)then
	pid = (PTBR - 1024)/8;
	//print pid;
	cpcb = (1536 + (pid * 32));
	count = 0;
	while(count < 8)do
		indexswoft = [cpcb + 15 + (2 * count)];
		[1344 + 2 * indexswoft + 1] = [1344 + 2 * indexswoft + 1]  - 1;
                if([1344 + 2 * indexswoft + 1] == 0)then
			[1344 + 2 * indexswoft] = -1;
                endif;
                [cpcb + 15 + (count * 2)] = -1;
		[cpcb + 16 + (count * 2)] = -1;
		count = count + 1;
	endwhile;
	[cpcb + 1] = 0;
	count = 0;
	while(count < 4)do
		alias memblock S10;
		memblock = [PTBR + (2 * count)];
		if(memblock == -1)then
			count = count + 1;
		else
			[1280 + memblock] = 0;
			[PTBR + (2 * count)] = -1;
			[PTBR + (2 * count) + 1] = "00";
			count = count + 1;
		endif;
	endwhile;
	cpcb = 1536;
	while(cpcb < 2559)do
		if([cpcb + 1] == 1)then
			break;
		else
			cpcb = cpcb + 32;
		endif;
	breakpoint;
	//print cpcb;
	endwhile;
	if(cpcb >= 2559)then
	halt;
	else
		BP = [cpcb + 2];
		SP = [cpcb + 3];
		R0 = [cpcb + 7];
		R1 = [cpcb + 8];
		R2 = [cpcb + 9];
		R3 = [cpcb + 10];
		R4 = [cpcb + 11];
		R5 = [cpcb + 12];
		R6 = [cpcb + 13];
		R7 = [cpcb + 14];
		PTBR = [cpcb + 5];
		PTLR = [cpcb + 6];
		SP = SP + 1;
		alias newphysicalSP S12;
		newphysicalSP = ([PTBR + 2 * (SP / 512) ] * 512) + (SP % 512);
		[newphysicalSP] = [cpcb + 4];
		[cpcb + 1] = 2;
		ireturn;
	endif;
else
	if(syscall == 13)then
		aliasa S6 argument;
		argument = [physicalSP - 3];
		alias S7 pid;
		pid = (PTBR - 1024)/8;
		if(pid == argument)then
			[physicalSP - 2] = -1;
			ireturn;
		endif;
		if([1536 + (argument * 32) + 1] == 0)
			[physicalSP - 2] = -1;
			ireturn;
		endif;
		[1536 + (pid * 32) + 1] = 100+argument;
		


endif;
